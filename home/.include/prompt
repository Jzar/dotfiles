# TODO: Fix prompt_char showing red when last command failed
# TODO: Fix all stupid colors
# TODO: Utilize new functions

### Prompt

## Shell functions

# Show number of background jobs
function show_jobs {
    echo "[$(jobs | wc -l)]"
}

# Show cwd, substituting tilde for home directory
function collapse_pwd {
    echo $(pwd | sed -e "s,^$HOME,~,")
}

## Python functions

# Show virtualenv info
function virtualenv_info(){
    if [[ -n $VIRTUAL_ENV ]]; then
        printf "%s%s" "%{${fg[yellow]}%}" ${${VIRTUAL_ENV}:t}
    fi
}

## VCS / Git functions

# Pick an appropriate prompt character
function prompt_char {
    # This doesn't work the way I want it to
    # [[ \$? -eq 0 ]] && : || echo -n "${fg[red]}"

    git branch >/dev/null 2>/dev/null && echo '±' && return
    hg root >/dev/null 2>/dev/null && echo '☿' && return
    echo '○'
}

# Show current git branch
function current_branch() {
    ref=$(git symbolic-ref HEAD 2> /dev/null) || \
    ref=$(git rev-parse --short HEAD 2> /dev/null) || return
    echo ${ref#refs/heads/}
}

function git_sha() {
    echo $(git rev-parse --short HEAD)
}

# Show remote ref name and number of commits ahead-of or behind
function remote_tracking_branch() (

    # Are we on a remote-tracking branch?
    remote=${$(git rev-parse --verify $(current_branch)@{upstream} --symbolic-full-name --abbrev-ref 2>/dev/null)}

    if [[ -n ${remote} ]] ; then
        ahead=$(git rev-list $(current_branch)@{upstream}..HEAD 2>/dev/null | wc -l)
        (( $ahead )) && gitstatus+="${green}+${ahead}${gray}"

        behind=$(git rev-list HEAD..$(current_branch)@{upstream} 2>/dev/null | wc -l)
        (( $behind )) && gitstatus+="${red}-${behind}${gray}"

        prompt_return_val=(${remote})
        (( $gitstatus )) && prompt_return_val+="${(j:/:)gitstatus}"
        echo $prompt_return_val
    fi
)

# Show count of stashed changes
function git_stash_count() {
    if [[ -s $(git rev-parse --show-toplevel)/.git/refs/stash ]] ; then
        stashes=$(git stash list 2>/dev/null | wc -l)
        echo "${stashes} stashed"
    fi
}

# Indicate if there are any untracked files present
function git-untracked() {

    # Check if there's at least 1 untracked file
    untracked=${$(git ls-files --exclude-standard --others | head -n 1)}

    if [[ -n ${untracked} ]] ; then
        echo "${hook_com[unstaged]}$FG[202]?"
    fi
}

function prompt_wrap() (
    d="$FG[025]"
    [[ -n $($1) ]] && echo "${d}[$($1)${d}]"
)

## Putting it all together

function getPrompt() (

    reset="%{${reset_color}%}"
    white="%{$fg[white]%}"
    gray="%{$fg_bold[black]%}"
    brgreen="%{$fg_bold[green]%}"
    red="%{$fg_bold[red]%}"
    yellow="%{$fg[yellow]%}"

    d="$FG[025]"
    name="$FG[133]%n"
    host="$FG[136]%M"
    green="$FG[070]"
    tstamp="$FG[037]%*"

    if [ $1 = l ]; then
        getPrompt_return=(
            "\n${d}[${name}${d}@${host}${d}]"
            "[${green}%~${d}]"
            '$(git_prompt_info)$(git-untracked)'
            "%(?..${d}[${red}!%?${reset}${d}])"
            "%(1j.${d}[$FG[226]%%%j${d}].)"
            '\n$(prompt_wrap virtualenv_info)'
            '%(!.#.$) '"${reset}"
        )
        echo $getPrompt_return
    elif [ $1 = r ]; then
        echo "${d}[${tstamp}${d}]${white}"
    fi
)

if [ $CURR_SHELL = zsh ]; then
    setopt prompt_subst
    PROMPT=$(getPrompt l)
    RPROMPT=$(getPrompt r)
else
    # TODO: Get an equivalent-ish prompt working for Bash
    # PS1=$(getPrompt l)
    :
fi
