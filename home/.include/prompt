#!/usr/bin/env bash
# TODO: Utilize new functions

### Prompt

## Python functions

# Show virtualenv info
function virtualenv_info(){
    if [[ -n $VIRTUAL_ENV ]]; then
        printf "%s%s" "%{${fg[yellow]}%}" ${${VIRTUAL_ENV}:t}
    fi
}

## VCS / Git functions

# Show current git branch
function current_branch() {
    ref=$(git symbolic-ref HEAD 2> /dev/null) || \
    ref=$(git rev-parse --short HEAD 2> /dev/null) || return
    echo ${ref#refs/heads/}
}

function git_sha() {
    echo $(git rev-parse --short HEAD)
}

# Show remote ref name and number of commits ahead-of or behind
function remote_tracking_branch() (

    # Are we on a remote-tracking branch?
    remote=$(git rev-parse --verify $(current_branch)@{upstream} --symbolic-full-name --abbrev-ref 2>/dev/null)

    if [[ -n ${remote} ]] ; then
        ahead=$(git rev-list $(current_branch)@{upstream}..HEAD 2>/dev/null | wc -l)
        (( $ahead )) && gitstatus+=($FG[010]+${ahead}$FG[025])

        behind=$(git rev-list HEAD..$(current_branch)@{upstream} 2>/dev/null | wc -l)
        (( $behind )) && gitstatus+=($FG[009]-${behind})

        prompt_return_val=$FG[202]${remote}
        [[ -n $gitstatus ]] && prompt_return_val+="$FG[025](${(j:/:)gitstatus}$FG[025])"
        echo $prompt_return_val
    fi
)

# Show count of stashed changes
function git_stash_count() {
    if [[ -s $(git rev-parse --show-toplevel)/.git/refs/stash ]] ; then
        stashes=$(git stash list 2>/dev/null | wc -l)
        echo "$FG[025]|$FG[202]$stashes"
    fi
}

# Indicate if there are any untracked files present
function git-untracked() {

    # Check if there's at least 1 untracked file
    untracked=${$(git ls-files --exclude-standard --others 2>/dev/null | head -n 1)}

    if [[ -n ${untracked} ]] ; then
        echo "${hook_com[unstaged]}$FG[202]?"
    fi
}

function parse_git_dirty {
  [[ $(git diff --shortstat 2> /dev/null | tail -n1) != "" ]] && echo "$FG[202]*"
}

function git_status {
    if git rev-parse --git-dir > /dev/null 2>&1; then
        echo $(remote_tracking_branch)$(parse_git_dirty)$(git-untracked)$(git_stash_count)
    fi;
}

function prompt_wrap() (
    d="$FG[025]"
    [[ -n $($1) ]] && echo "${d}[$($1)${d}]"
)

## Putting it all together

function getPrompt() (

    reset="%{${reset_color}%}"
    white="%{$fg[white]%}"
    gray="%{$fg_bold[black]%}"
    brgreen="%{$fg_bold[green]%}"
    red="%{$fg_bold[red]%}"
    yellow="%{$fg[yellow]%}"

    d="$FG[025]"
    name="$FG[133]%n"
    host="$FG[136]%M"
    green="$FG[070]"
    tstamp="$FG[037]%*"

    if [ $1 = l ]; then
        getPrompt_return=(
#            "\n${d}[${name}${d}@${host}${d}]"
            "\n${d}[${green}%~${d}]"
            '$(prompt_wrap git_status)'
            '$(prompt_wrap virtualenv_info)'
            "%(?..${d}[${red}!%?${reset}${d}])"
            "%(1j.${d}[$FG[226]%%%j${d}].)"
            "\n${d}%(!.#.$) ${reset}"
        )
        echo $getPrompt_return
    elif [ $1 = r ]; then
        echo "${d}[${tstamp}${d}]${white}"
    fi
)

if [ $CURR_SHELL = zsh ]; then
    setopt prompt_subst
    PROMPT=$(getPrompt l)
    RPROMPT=$(getPrompt r)
else
    # TODO: Get an equivalent-ish prompt working for Bash
    # PS1=$(getPrompt l)
    :
fi
